import java.awt.Color;
import java.util.HashMap;
import java.util.LinkedList;

import org.jgraph.graph.DefaultGraphCell;


public class HeapFake extends Drawer{
	LinkedList<Node> list;
	public HeapFake(){
		list = new LinkedList<Node>();
	}
	
	public boolean add(int a){
		if(!contains(a)){
			list.add(list.size(), new Node(a));
			System.out.println(a);
			return true;
		}
		return false;
	}
	
	public boolean contains(int a){
		for(Node b : list){
			if(b.getKey() == a)
				return true;
		}
		return false;
	}
	public void draw(){
		int x = (int) DEFAULT_SIZE.width/2;
		int y = 30;
		int lvl = 1;
		HashMap<Integer,DefaultGraphCell> cells = new HashMap<Integer, DefaultGraphCell>();
		for(int i = 0; i < list.size(); i++){
			createMyVertex(cells, list.get(i), x, y, Color.red);
			list.get(i).setX(x);
			if(i % 2 == 1){ //vulgo Ã© da direita
				System.out.println(x + " eh direita");
				x = (int) (list.get((i+1)/2 - 1).getX() + (int) DEFAULT_SIZE.width/Math.scalb(1., lvl+1));
			}else{
				if(i != 0){
					System.out.println(x + " eh esquerda");
					x = (int) (list.get((i+1)/2 -1).getX() - (int) DEFAULT_SIZE.width/Math.scalb(1., lvl+1));
					System.out.println("novo x " + x + " e " + DEFAULT_SIZE.width/Math.scalb(1., i+2));
				}
				else
					x = (int) (list.get((i+1)/2).getX() - (int) DEFAULT_SIZE.width/Math.scalb(1., lvl+1));
			}
			if(Math.scalb(1., lvl)-2 == i){
				y+=deltaY;
				lvl++;
			}
		}
		
		jgraph.getGraphLayoutCache().insert(cells.values().toArray());
		drawStructure(jgraph);
	}
}
